this worth making a video about, how can we borrow something that is already being borrowed

for instance if you try to add the following line "vector::borrow_mut(&mut shop.items, item_id).available = shop_item.available - quantity;" instead of item.available = item.available - quantity; you will be told that: Invalid usage of reference as function argument. Cannot transfer a mutable reference that is being borrowed, and yet we are still able to borrow at the end of the function on the last if condition. what is going here ? 




public fun purchase_item(
        shop: &mut Shop, 
        item_id: u64,
        quantity: u64,
        recipient: address,
        payment_coin: &mut coin::Coin<SUI>,
        ctx: &mut TxContext
    ) {

        // Abort if the item id is invalid, 
        assert!(item_id <= vector::length(&shop.items), EInvalidItemId);
        
        let item = vector::borrow_mut(&mut shop.items, item_id);
        
        // or the shop does not have enough available supply. 
        assert!(item.available >= quantity, EInvalidQuantity);

        // the payment coin is insufficient, 
        let value = coin::value(payment_coin);
        let total_price = item.price * quantity;
        assert!(value >= total_price, EInsufficientPayment);

        // if the item is unlisted, 
        assert!(item.listed == true, EItemIsNotListed);

        //Purchases an item from the shop and 
        item.available = item.available - quantity;

        let paid = coin::split(payment_coin, total_price, ctx);

        coin::put(&mut shop.balance, paid);

        let i = 0_u64;

        while (i < quantity) {
            let purchased_item_uid = object::new(ctx);

            transfer::transfer(PurchasedItem {
                id: purchased_item_uid,
                shop_id: object::uid_to_inner(&shop.id),
                item_id: item_id }, recipient);

            i = i+1;
        };

        // emits an ItemPurchased event. 
        event::emit(ItemPurchased {
            shop_id: object::uid_to_inner(&shop.id),
            item_id: item_id,
            quantity: quantity,
            buyer: recipient,
        });

        // Emit an ItemUnlisted event if the last item(s) are purchased.
        if (item.available == 0 ) {
            event::emit(ItemUnlisted{
                shop_id: object::uid_to_inner(&shop.id),
                item_id: item_id,
            });

            vector::borrow_mut(&mut shop.items, item_id).listed = false;
        }
    }

